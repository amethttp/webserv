###########################################################################################
#
# Prior knowledge to parse and build HTTP 1.1 messages:
#
# #########################
# #     HTTP MESSAGES     #
# #########################
#
# 1.  HTTP message consists of:
#     - start-line CRLF -------------> start-line followed by CRLF
#     - *( header section CRLF ) ----> zero or more headers followed by CRLF
#     - CRLF ------------------------> empty line followed by CRLF
#     - [ message-body ] ------------> optional message body
#
#
# 2.  Messages are requests or responses, and syntactically differ only in the start-line
#     and in the algorithm for determining the length of the message body:
#     - request start-line ----> request-line
#     - response start-line ---> status-line
#
#  
# 3.  Normal procedure to parse an HTTP message:
#     - 1. Read the start-line into a structure
#     - 2. Read each header into a hash table / map until the empty line
#     - 3. Determine if a body message is expected using the parsed data
#        - If a message body has been indicated, it is read as a stream until the number of bytes read equals the body length, or the connection is closed
#
#
# 4.  Before parsing request data to unicode, you MUST parse it, to prevent missing control characters
#
#
# 5.  You MAY use only LF to separate headers instead of CRLF, but you MUST NOT use only CR to separate them
#
#
# 6.  The user agent MUST NOT preface or follow a request with an extra CRLF. If terminating a request body
#     with a CRLF is desired, the user agent MUST count the terminating CRLF bytes as part of the body
#
#
# 7.  For robustness, a server SHOULD ignore at least one empty line received prior to the request-line
#
#
# 8.  A sender MUST NOT send whitespaces between the start-line and the first header field. If this happens,
#     the receiver should reject the message as invalid or ignore the line and any subsequent ones preceded
#     with whitespaces until a properly formed header is received or the header section is terminated.
#
#
# 9.  If a server receives a sequence of bytes that does not match the HTTP-message grammar described above
#     (aside from the robustness exceptions), the server SHOULD respond with a 400 Bad Request response and
#     close the connection
#
#
# 10. The HTTP version used by a server or client is described as HTTP "/" DIGIT "." DIGIT (HTTP/1.1)
#
#
#
# #########################
# #     REQUEST LINES     #
# #########################
#
# 11. The request-line is composed as: method SP request-target SP HTTP-version (GET / HTTP/1.1). Although it's
#     required that each of the component elements is separated by a single SP byte, receivers MAY parse multiple
#     whitespaces (whitespace deilimited word boundaries), and, aside from CRLF terminator, treat any form of
#     whitespaces as the SP separator, although this can lead to HTTP smuggling attacks
#
#
# 12. The request-line has no length limit. However, a server SHOULD parse a received protocoll element defensively:
#     - As a minimum, a server MUST parse at least the length used in the responses it builds. For example, if the server
#       creates a response for a resource with a length of 1000 bytes, it MUST parse at least 1000 bytes of request line length
#     - A server that receives a method longer than any that it implements (or a method it doesn't understand) SHOULD respond
#       with a 501 Not Implemented
#     - A server that receives a request-target longer than any URI it wishes to parse MUST respond with a 414 URI Too Long
#     - It is RECOMMENDED that senders and receivers support, at a minimum, lengths of 8000 bytes
#
#
# 13. The request-target identifies the target resource upon which to apply the request. No whitespace is allowed in the
#     request-target (if this happen, it SHOULD respond with either a 400 Bad Request or a 301 Moved Permanently redirect with
#     the request-target properly encoded).
#
#
# 14. A client MUST send a Host header in all HTTP/1.1 request messages. The Host field MUST follow the next guidelines (in case
#     of failure, the server MUST send a 400 Bad Request):
#     - It SHOULD be the first field to appear (not strictly necessary)
#     - The next composition: uri-host [ ":" port] (domain.com[:80]). The uri-host may be:
#        - Valid domain name
#        - IPv4 direction
#        - IPv6 direction using [] ([::1])
#     - MUST NOT be empty
#     - MUST NOT contain prohibited characters (whitespace or non-printable characters)
#     - MUST NOT contain non-numeric port
#     - MUST NOT contain malformed ":" or multiple ports
#     - MUST NOT be missing or duplicated
#     - MUST NOT contain an IPv6 malformed (e.g., missing [])
#
#
# 15. The request-target has four distinct formats. The origin-form is the only one necessary here. The origin-form consists of:
#     absolute-path [ "?" query ] (/file.txt?param=value) --- this is the URL ---> http://my.domain.com/file.txt?param=value
#
#
#
# #########################
# #     STATUS  LINES     #
# #########################
#
# 16. The status-line consists of: HTTP-version SP status-code SP [ reason-phrase ] (HTTP/1.1 404 Not Found). The SP MAY be replaced
#     the same way as in request-line. The status-code element is a 3-digit integer code. The reason-phrase SHOULD be ignored by the
#     client, as its optional and can varie, therefore its not a reliable channel for information. Thus, the server MUST send the SP
#     that separates the status-code from the reason-phrase, even if the latter is absent (i.e., the status-line would end with SP).
#
#
#
# #########################
# #     HEADER SYNTAX     #
# #########################
#
# 17. A header field (field line) consists of: case-insensitive field-name ":" OWS field-value OWS. For example:
#     (Host:[ ]locahost[ ]). The OWS MUST be trimmed. Headers SHOULD follow:
#     - Host and Connection headers SHOULD be recognized by all HTTP implementations. Connection MAY be:
#       - close: Closes the connection after sending the response
#       - keep-alive (default in HTTP/1.1): keeps the connection open after sending the response
#     - Receivers SHOULD ignore unrecognized header and trailer fields
#     - A server that receives a header larger that it wishes to parse MUST respond with a 4xx (Client error) response.
#     - Header keys SHOULD contain only ALPHA, DIGIT and hyphens ('-'). But MUST NOT contain other characters that are not tchars:
#       ALPHA DIGIT ! # $ % & ' * + - . ^ _ ` | ~
#     - Header values MUST NOT contain control characters (except for HTAB)
#     - Header values
#
#
# 18. A server MUST reject with 400 Bad Request any received request message that contains whitespace between the header key and colon.
#     (e.g., "Host :localhost")
#
#
#
# #########################
# #     MESSAGES BODY     #
# #########################
#
# 19. The rules to determine when a message body is present in an HTTP/1.1 differs for requests and responses:
#     - Requests: Determined by the presence of Content-Length or Transfer-Encoding (independent of the request method)
#     - Responses: Determined by the method to which it is responding to and the response status code
#
#
# 20. A receiver MUST be able to parse the chunked transfer coding (Transfer-Encoding: chunked), as its crucial when bodies are not known
#     in advance. A sender MUST NOT apply the chunked transfer coding more than once to a message body. If any transfer coding other than
#     chunked is applied to a request's content, the sender MUST apply chunked as the final transfer coding. If any transfer coding other
#     than chunked is applied to a response's content, the sender MUST either apply chunked as the final coding or close the connection.
#     Example: Transfer-Encoding: gzip, chunked -------> First compressed with gzip coding and then sent in chunks.
#
#
# 21. Transfer-Encoding MUST follow:
#     - It MAY be sent in a 304 Not Modified response to a GET request
#     - A server MUST NOT send Transfer-Encoding header in any response with status code of 1xx (Informational) or 204 No Content.
#     - A server that receives a request message with a transfer coding it does not understand SHOULD respond with 501 Not Implemented
#     - A client or server that receives an HTTP/1.0 (yes, 1.0) containing Transfer-Encoding MUST treat the message as faulty.
#
#
# 22. A server MAY reject a request that contains both Content-Length and Transfer-Encoding or process such a request in acordance with the
#     Transfer-Encoding alone. Regardless, the server MUST close the conection after responding to such a request to avoid attacks.
#
#
# 23. Content-Length appears when Transfer-Encoding is not present. A sender MUST NOT send a Content-Length header in any message that
#     contains a Transfer-Encoding field
#
#
# 24. Message body length is determined by:
#     - Any response with a 1xx (Informational), 204 No Content or 304 Not Modified status code is always terminated by the first empty line
#       after the header fields, regardless of the headers present in the message, thus cannot contain a message body
#     - If a message contains an invalid Content-Length, the receiver MUST treat it as an unrecoverable error. If this happens in a request,
#       the server must respond with 400 Bad Request and close the connection.
#     - If the body is larger than the stated Content-Length, the server MUST respond with 400 Bad Request
#     - If the Content-Length is not fully received and the connection is closed, the message is invalid and MUST be discarded
#     - A timeout MAY be used to wait for the full body, but once timed out, it MUST be treated as incomplete.
#     - If a valid Content-Length is present, the decimal value represents the exact length. If the sender clsoes the connection or the receiver
#       times out before the number of bytes are received, the recipient MUST consider the message to be incomplet and close the connection
#     - If this is a request message and none of the above are true, then the message body length is zero, thus no message body is present
#
#
# 25. A server SHOULD generate encoding or length-delimited messages whenever possible, as there is no way to distinguish a successfully completed
#     close-delimited response message from a partially received message interrupted by a network failure
#
#
# 26. Transfer-Encoding names (chunked) is case-insensitive
#
#
# 27. A chunked body consists of:
#     1. *chunk -------------------------> zero or multiple chunks (chunk-size [ chunk-ext ] CRLF)
#                                                                  (chunk-value CRLF)
#     2. last-chunk ---------------------> a chunk with 0 chunk-size
#     3. trailer-section ----------------> dynamic metadata
#     4. CRLF
#
#
# 28. The chunk-size field is a string of hexadecimal digits indicating the size of the chunk-data in bytes. The chunked body is complete when a chunk
#     with a chunk-size of zero is received, OPTIONALLY followed by a trailer section and finally terminated by an empty line (CRLF)
#
#
# 29. Chunks MAY include chunk-ext or chunk extensions, metadata for each chunk. It consists of: ";" chunk-ext-name [ "=" chunk-ext-val ]. It is immediately
#     following the chunk-size. Example: 5;ext-key=ext-value\r\n. A receiver MUST ignore unrecognized chunk extensions. It ought limit the extensions length.
#
#
# 30. The trailer section is used to add dynamically generated metada. It consists of: *( field-line CRLF ). A receiver that builds the chunked body MAY discard
#     the received trailer fields. 
#
#
###########################################################################################
###########################################################################################
# 
# REQUEST GRAMMAR
# 
#---# ABNF Core Rules: #---#
# 
#   ---
#   - CR              =  %x0D                        ; Carriage return (\r)
#   - LF              =  %x0A                        ; Linefeed (\n)
#   - CRLF            =  CR LF                       ; Internet standard newline (\r\n)
#   - SP              =  %x20                        ; Space (' ')
#   - HTAB            =  %x09                        ; Horizontal tab (\t)
#   - DQUOTE          =  %x22                        ; Double quote ('"')
#   - ALPHA           =  %x41-5A / %x61-7A           ; A-Z / a-z
#   - DIGIT           =  %x30-39                     ; 0-9
#   - HEXDIG          =  DIGIT / "A-F" / "a-f"       ; A-Z / a-z
#   - OCTET           =  %x00-FF                     ; 1 byte of data
#   - VCHAR           =  %x21-7E                     ; Visible printing characters ("!" - "~")
#   ---
# 
# 
#---# RFC HTTP-messages grammar #---#
# 
#   HTTP-message      = start-line CRLF
#                       *( field-line CRLF )            --->    MUST have Host header (no repetitions)
#                       CRLF
#                       [ message-body ]
# 
# 
#   start-line        = request-line / status-line
# 
# 
#   request-line      = method SP request-target SP HTTP-version
#  
# 
#   method            = token             --->     CASE-SENSITIVE
# 
# 
#   token             = 1*tchar
# 
# 
#   tchar             = "!" / "#" / "$" / "%" / "&" / "'" / "*" / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~" / DIGIT / ALPHA
# 
# 
#   request-target    = origin-form
# 
# 
#   origin-form       = absolute-path [ "?" query ]
# 
# 
#   absolute-path     = 1*( "/" segment )
# 
# 
#   segment           = *pchar
# 
# 
#   pchar             = unreserved / pct-encoded / sub-delims / ":" / "@"
# 
# 
#   unreserved        = ALPHA / DIGIT / "-" / "." / "_" / "~"
# 
# 
#   pct-encoded       = "%" HEXDIG HEXDIG
# 
# 
#   sub-delims        = "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
# 
# 
#   query             = *( pchar / "/" / "?" )
# 
# 
#   HTTP-version      = HTTP-name "/" DIGIT "." DIGIT          --->     CASE-SENSITIVE
# 
# 
#   HTTP-name         = %s"HTTP"
# 
# 
#   status-line       = HTTP-version SP status-code SP [ reason-phrase ]
# 
# 
#   status-code       = 3 DIGIT 
# 
# 
#   reason-phrase     = 1*( HTAB / SP / VCHAR / obs-text )
# 
# 
#   field-line        = field-name ":" OWS field-value OWS
# 
# 
#   field-name        = token               --->     CASE-INSENSITIVE
# 
# 
#   OWS               = *( SP / HTAB )    ; optional WS (should trim)
# 
# 
#   field-value       = *field-content
# 
# 
#   field-content     = field-vchar [ 1*( SP / HTAB / field-vchar ) field-vchar ]
# 
# 
#   field-vchar       = VCHAR / obs-text
# 
# 
#   obs-text          = %x80-FF           --->     We will not recognize them (400 Bad Request)
#
# 
#   message-body      = *OCTET            --->     Size based on Content-Length or Transfer-Encoding: chunked 
# 
# 
#   chunked-body      = *chunk
#                       last-chunk
#                       trailer-section
#                       CRLF
# 
# 
#   chunk             = chunk-size [ chunk-ext ] CRLF
#                       chunk-data CRLF
# 
# 
#   chunk-size        = 1*HEXDIG
# 
# 
#   chunk-ext         = *( ";" chunk-ext-name [ "=" chunk-ext-val ] )
# 
# 
#   chunk-ext-name    = token
# 
# 
#   chunk-ext-val     = token / quoted-string
# 
# 
#   quoted-string     = DQUOTE *( qdtext / quoted-pair ) DQUOTE
# 
# 
#   qdtext            = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text     --->   HTAB / SP / '!' / '#' - '[' / ']' - '~' / obs-text
# 
# 
#   quoted-pair       = "\" ( HTAB / SP / VCHAR / obs-text )
# 
# 
#   chunk-data        = 1*OCTET    --->    MUST be exactly chunk-size octets
# 
# 
#   last-chunk        = 1*("0") [ chunk-ext ] CRLF
# 
# 
#   trailer-section   = *( field-line CRLF )
# 
#  
#---# Mandatory headers grammar #---#
# 
#   Connection:       = "keep-alive" / "close"           --->  CASE-INSENSITIVE
# 
# 
#   Host:             = reg-name ":" port            --->  CASE-INSENSITIVE   --->  MUST NOT BE EMPTY NOR DUPLICATED
#   reg-name          = *( unreserved / pct-encoded / sub-delims)  
#   port              = 1*DIGIT                       --->  0 => port <= 65335
#  
#  
#   Content-Length    = 1*DIGIT
# 
# 
#   Transfer-Encoding = "chunked"           --->    Tranfer-coding chunked (chunked-body)     --->     CASE-INSENSITIVE (CHUNKED == chunked)
#  
#  
#   Content-Length and Transfer-Encoding ---> 400 Bad Request
#  
#  
###########################################################################################
###########################################################################################
#
# Sources:
# RFC key words: https://www.rfc-editor.org/rfc/rfc2119.txt
# HTTP 1.1 documentation: https://www.rfc-editor.org/rfc/rfc9112.html
# HTTP Semantics documentation: https://www.rfc-editor.org/rfc/rfc9110.html
# HTTP URI semantics https://www.rfc-editor.org/rfc/rfc3986
# ABNF Core rules https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1
#
###########################################################################################

# ACCEPTANCE CRITERIA:

## Request line (RQL)
### 1. Fail with 400 Bad Request for INVALID request-line preceded by a SP 
" GET / HTTP/1.1"

### 2. Fail with 400 Bad Request for INVALID request-line followed by a SP 
"GET / HTTP/1.1 "

### 3. Fail with 400 Bad Request for INVALID request-line with 4 elements 
"INVALID GET / HTTP/1.1"

### 4. Fail with 400 Bad Request for INVALID request-line with 4 elements 
"GET / HTTP/1.1 INVALID"

### 5. Fail with 400 Bad Request for INVALID request-line
"INVALID"

### 6. Fail with 400 Bad Request for a only space request-line
" "

### 7. Fail with 400 Bad Request for an empty request-line
""


### METHOD CRITERIA
### 1. Basic GET RQL (works)
"GET / HTTP/1.1"

### 2. Basic POST RQL (works)
"POST / HTTP/1.1"

### 3. Basic DELETE RQL (works)
"DELETE / HTTP/1.1"

### 4. Fail with 501 Not Implemented for case-insensitive method
"get / HTTP/1.1"

### 5. Fail with 501 Not Implemented for not-recognized method with only alphabetic characters
"INVALID / HTTP/1.1"

### 6. Fail with 501 Not Implemented for not-recognized method of tchars
"!#$%&'*+-.^_`|~0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz / HTTP/1.1"

### 7. Fail with 400 Bad Request for non-token (tchars) method
"(),/:;\r<=>\b?@\f[\\]\t{}\n / HTTP/1.1"

### 8. Fail with 400 Bad Request for method containing non-token chars (tchars)
"DEL(),/:;\r<=>\b?@\f[\\]\t{}\nTE / HTTP/1.1"

### 9. Fail with 400 Bad Reqest for empty method
" / HTTP/1.1"

### 10. Fail with 400 Bad Request for non-existant method
"/ HTTP/1.1"


### FIRST SPACE CRITERIA
### 1. Fail with 400 Bad Request if it doesn't have an SP
"GET/ HTTP/1.1"

### 2. Fail with 400 Bad Request if it has another character instead of SP
"GET?/ HTTP/1.1"

### 3. Fail with 400 Bad Request if it has a tabulation instead of SP
"GET\t/ HTTP/1.1"

### 4. Fail with 400 Bad Request if it has a tabulation and a SP
"GET\t / HTTP/1.1"

### 5. Fail with 400 Bad Request if it has a SP and a tabulation
"GET \t/ HTTP/1.1"

### 6. Fail with 400 Bad Request if it has multiple SP
"GET   / HTTP/1.1"

### LAST SPACE CRITERIA
### 1. Fail with 400 Bad Request if it doesn't have an SP
"GET /HTTP/1.1"

### 2. Fail with 400 Bad Request if it has another character instead of SP
"GET /?HTTP/1.1"

### 3. Fail with 400 Bad Request if it has a tabulation instead of SP
"GET /\tHTTP/1.1"

### 4. Fail with 400 Bad Request if it has a tabulation and a SP
"GET /\t HTTP/1.1"

### 5. Fail with 400 Bad Request if it has a SP and a tabulation
"GET / \tHTTP/1.1"

### 6. Fail with 400 Bad Request if it has multiple SP
"GET /   HTTP/1.1"


### HTTP VERSION CRITERIA
### 1. Fail with 400 Bad Request for case-insensitive HTTP-name
"GET / Http/1.1"
"GET / http/1.1"

### 2. Fail with 400 Bad Request for an invalid HTTP-name
"GET / INVALID/1.1"
"GET / \rIN\b31VA\n()!%&9/LID/1.1"

### 3. Fail with 400 Bad Request for repeated HTTP-name
"GET / HTTPHTTP/1.1"

### 4. Fail with 400 Bad Request for SP instead of HTTP-name
"GET /  /1.1"

### 5. Fail with 400 Bad Request for HTAB instead of HTTP-name
"GET / \t/1.1"

### 6. Fail with 400 Bad Request for empty HTTP-name
"GET / /1.1"

### 7. Fail with 400 Bad Request for an invalid '/'
"GET / HTTP?1.1"
"GET / HTTP$1.1"

### 8. Fail with 400 Bad Request for repeated '/'
"GET / HTTP//1.1"

### 9. Fail with 400 Bad Request for SP instead of '/'
"GET / HTTP 1.1"

### 10. Fail with 400 Bad Request for HTAB instead of '/'
"GET / HTTP\t1.1"

### 11. Fail with 400 Bad Request for empty '/'
"GET / HTTP1.1"

### 12. Fail with 500 HTTP Version Not Supported for major version different of 1
"GET / HTTP/0.1"
"GET / HTTP/2.1"

### 13. Fail with 400 Bad Request for invalid major version
"GET / HTTP/1fA($!.1"
"GET / HTTP/fe\r\b1.1"

### 14. Fail with 400 Bad Request for not single-digit major version
"GET / HTTP/11.1"

### 15. Fail with 400 Bad Request for negative major version
"GET / HTTP/-1.1"

### 16. Fail with 400 Bad Request for SP instead of major version
"GET / HTTP/ .1"

### 17. Fail with 400 Bad Request for HTAB instead of major version
"GET / HTTP/\t.1"

### 18. Fail with 400 Bad Request for empty major version
"GET / HTTP/.1"

### 19. Fail with 400 Bad Request for invalid '.'
"GET / HTTP/1(1"
"GET / HTTP/1F_1"

### 20. Fail with 400 Bad Request for repeated '.'
"GET / HTTP/1..1"

### 21. Fail with 400 Bad Request for SP instead of '.'
"GET / HTTP/1 1"

### 22. Fail with 400 Bad Request for HTAB instead of '.'
"GET / HTTP/1\t1"

### 23. Fail with 400 Bad Request for empty '.'
"GET / HTTP/11"

### 24. Fail with 505 HTTP Version Not Supported for minor version different of 1
"GET / HTTP/1.0"
"GET / HTTP/1.2"

### 25. Fail with 400 Bad Request for invalid minor version
"GET / HTTP/1.1fA($!"
"GET / HTTP/1.fe\r\b1"

### 26. Fail with 400 Bad Request for not single-digit minor version
"GET / HTTP/1.11"

### 27. Fail with 400 Bad Request for negative minor version
"GET / HTTP/1.-1"

### 28. Fail with 400 Bad Request for SP instead of minor version
"GET / HTTP/1. "

### 29. Fail with 400 Bad Request for HTAB instead of minor version
"GET / HTTP/1.\t"

### 30. Fail with 400 Bad Request for empty minor version
"GET / HTTP/1."

### 31. Fail with 400 Bad Request for INVALID HTTP-version
"GET / INVALID"

### 32. Fail with 400 Bad Request for INVALID HTTP-version
"GET / 1.1"

### 33. Fail with 400 Bad Request for incomplete HTTP-version
"GET / HTTP"
"GET / HTTP//"
"GET / HTTP/1"
"GET / HTTP/1."

### 32. Fail with 400 Bad Request for multiple minor versions HTTP-version
"GET / HTTP/1.1.1"

### 34. Fail with 400 Bad Request for empty HTTP-version
"GET / "

### 34. Fail with 400 Bad Request for non-existant HTTP-version
"GET /"



# TEST "GET / HTTP/1.1\t" ON THE VERSION
# TEST "GET / HTTPINVALID/1.1" ON THE VERSION



# TESTS:

# 1. Basic GET and DELETE requests
"GET / HTTP/1.1\r\nHost: localhost\r\n\r\n"
"DELETE / HTTP/1.1\r\nHost: localhost\r\n\r\n"

# 2. Basic POST request
"POST / HTTP/1.1\r\nHost: localhost\r\nContent-Length: 0\r\n\r\n"

# 3. Fail with invalid HTTP method
"INVALID / HTTP/1.1\r\nHost: localhost\r\n\r\n"

# 2. Single request, works
"GET /index.html HTTP/1.1\r\nHost: localhost\r\nUser-Agent: nc\r\nAccept: */*\r\n\r\n"

# 3. Missing Host header, 400 Bad Request
"GET / HTTP/1.1\r\n\r\n"

# 4. Wrong request line (double space), 400 Bad Request
"GET  / HTTP/1.1\r\nHost: localhost\r\n\r\n"

# 5. Well-formed GET with body, works ignoring the body
"GET / HTTP/1.1\r\nHost: localhost\r\nContent-Length: 5\r\n\r\nHello"

# 6. Single request, works
"POST /submit HTTP/1.1\r\nHost: localhost\r\nContent-Length: 8\r\n\r\nfoo=bar\n"

# 7. POST without Content-Length, 411 Length Required
"POST /submit HTTP/1.1\r\nHost: localhost\r\n\r\nfoo=bar\n"

# 8. Content-Length not numeric, 400 Bad Request
"POST /submit HTTP/1.1\r\nHost: localhost\r\nContent-Length: abc\r\n\r\nfoo=bar"

# 9. Single request, works
"POST /api/data HTTP/1.1\r\nHost: localhost\r\nContent-Type: application/json\r\nContent-Length: 15\r\n\r\n{\"key\":\"value\"}"

# 10.Content-Length bigger than real body, 408 Request Timeout (or 400 Bad Request as the request has content)
"POST /form HTTP/1.1\r\nHost: localhost\r\nContent-Length: 20\r\n\r\nshort body"

# 11. Multiple requests, works
"POST /form HTTP/1.1\r\nHost: localhost\r\nContent-Length: 20\r\n\r\nshort body" && "short body"

# 12. Single request, works
"DELETE /resource HTTP/1.1\r\nHost: localhost\r\n\r\n"

# 13. Has body without Content-Length, 411 Length Required
"DELETE /resource HTTP/1.1\r\nHost: localhost\r\n\r\nsome body"

# 14. Well-formed DELETE with body, works ignoring the body
"DELETE /resource HTTP/1.1\r\nHost: localhost\r\nContent-Length: 9\r\n\r\nsome body"

# 15. Single request, works
"GET /search?q=calistenia HTTP/1.1\r\nHost: localhost\r\n\r\n"

# 16. Invalid HTTP version, 505 HTPP Version Not Supported
"GET / HTTP/1.5\r\nHost: localhost\r\n\r\n"

# 17. Well-formed request with repeated headers, works with the second header overriding the first one
"GET / HTTP/1.1\r\nHost: localhost\r\nHost: cfidalgo.42.fr\r\n\r\n"

# 18. Doesn't end the headers with \r\n\r\n, 408 Request Timeout (or 400 Bad Request as the request has content)
"GET / HTTP/1.1\r\nHost: localhost\r\n"

# 19. Multiple requests, works
"GET / HTTP/1.1\r\nHost: localhost\r\n" && "\r\n"

# 20. "Really long" request (works?)
"GET /%08000d HTTP/1.1\r\nHost: localhost\r\n\r\n", 1 | nc localhost 8080

# 21. Header key contains a non-tchar (https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.6), 400 Bad Request
"GET / HTTP/1.1\r\nHost: localhost\r\nUser-:Agent: nc\r\n\r\n"

# 22. Header key contains control chars, 400 Bad Request
"GET / HTTP/1.1\r\nHost: localhost\r\nUser-Agent\t: nc\r\n\r\n"

# 23. Header value contains control chars and is not \t or ' ', 400 Bad Request
"GET / HTTP/1.1\r\nHost: localhost\r\r\nUser-Agent: nc\r\n\r\n"

# 24. Single request, works
"POST /data HTTP/1.1\r\nHost: localhost\r\nTransfer-Encoding: chunked\r\n\r\n4\r\ndata\r\n0\r\n\r\n"

# 25. Multiple requests, works
"POST /data HTTP/1.1\r\nHost: localhost\r\nTransfer-Encoding: chunked\r\n\r\n4\r" && "\nda" && "ta\r\n0\r\n\r\n"

# 26. Multiple requests. First doesn't work as chunk-size is non-numeric (abc). Second (last 2 printfs) don't work, as all headers are missing
"POST /data HTTP/1.1\r\nHost: localhost\r\nTransfer-Encoding: chunked\r\n\r\nabc\r" && "\nda" && "ta\r\n0\r\n\r\n"

# 27. Multiple requests. First doesn't work as chunk-size is non-numeric (4\r). Second (last 2 printfs) don't work, as all headers are missing
"POST /data HTTP/1.1\r\nHost: localhost\r\nTransfer-Encoding: chunked\r\n\r\n4\r\r" && "\nda" && "ta\r\n0\r\n\r\n"

# 28. Single request, works
"POST /data HTTP/1.1\r\nHost: localhost\r\nContent-Length: 6\r\n\r\ndata\r\n"

# 29. Chunk size is empty, 411 Length Required
"POST /data HTTP/1.1\r\nHost: localhost\r\nTransfer-Encoding: chunked\r\n\r\n\r\ndata\r\n0\r\n\r\n"

# 30. Single request, works
"POST /data HTTP/1.1\r\nHost: localhost\r\nTransfer-Encoding: chunked\r\n\r\n" && "0\r\n\r\n"
